package org.crypttech.modexp.testgenerator.format;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.crypttech.modexp.testgenerator.TestVector;

public class GeneratorVerilog extends ModExpTestFormater {
	private BufferedReader br;
	private List<String> taskCalls = new ArrayList<String>();
	private boolean initilized = false;
	private List<String> taskTemplate = new ArrayList<String>();

	public GeneratorVerilog(String templateFile, String destinationFile)
			throws FileNotFoundException {
		super(new PrintWriter(destinationFile), true);
		this.br = new BufferedReader(new InputStreamReader(new FileInputStream(
				templateFile)));

	}

	@Override
	public void format(TestVector testVector) {
		init();

		String testname = ("autogenerated_" + testVector.generator + "_" + testVector.seed)
				.replace("-", "M");
		taskCalls.add(testname + "();");

		for (String line : taskTemplate) {
			line = line.replace("TEMPLATE_TASK_NAME", testname);
			if (line.contains("TEMPLATE_EXPECTED_VALUES"))
				emitArray(line, testVector.expected);
			else if (line.contains("TEMPLATE_MESSAGE_VALES"))
				emitArray(line, testVector.X);
			else if (line.contains("TEMPLATE_EXPONENT_VALES"))
				emitArray(line, testVector.E);
			else if (line.contains("TEMPLATE_MODULUS_VALUES"))
				emitArray(line, testVector.M);
			else if (line.contains("TEMPLATE_EXPECTED_LENGTH"))
				emitLength(line, testVector.expected);
			else if (line.contains("TEMPLATE_MESSAGE_LENGTH"))
				emitLength(line, testVector.X);
			else if (line.contains("TEMPLATE_EXPONENT_LENGTH"))
				emitLength(line, testVector.E);
			else if (line.contains("TEMPLATE_MODULUS_LENGTH"))
				emitLength(line, testVector.M);
			else
				out(line);
		}
	}

	private void emitLength(String pattern, int[] array) {
		String lengthHexString = hex32(array.length);
		String line = pattern.replace("#TL#", lengthHexString);
		out(line);
	}

	private void emitArray(String pattern, int[] array) {
		for (int i = 0; i < array.length; i++) {
			String indexHexString = hex8(i);
			String arrayHexString = hex32(array[i]);
			String line = pattern.replace("#TI#", indexHexString).replace(
					"#TD#", arrayHexString);
			out(line);
		}
	}

	private String hex8(int data) {
		return String.format("%02x", data);
	}

	private String hex32(int data) {
		return String.format("%08x", data);
	}
	
	@Override
	public void close() throws Exception {
		emitMiddle();
		for (String taskCall : taskCalls)
			out(taskCall);
		emitFinal();
		if (br != null)
			br.close();
		super.close();
	}

	private void init() {
		if (initilized == true)
			return;
		initilized = true;
		emitHeader();
		taskTemplate.addAll(consumeTemplate("TEMPLATE_TEST_DEFINITION_END"));
	}

	private void emitHeader() {
		String terminatingLine = "===TEMPLATE_HEADER_END===";
		emitTemplateSection(terminatingLine);
	}

	private void emitMiddle() {
		String terminatingLine = "===TEMPLATE_CALL_TASKS===";
		emitTemplateSection(terminatingLine);
	}

	private void emitFinal() {
		String terminatingLine = "Never gonna give you up, never gonna let you down";
		emitTemplateSection(terminatingLine);
	}

	private void emitTemplateSection(String terminatingLine) {
		List<String> lines = consumeTemplate(terminatingLine);
		for (String line : lines)
			out(line);
	}

	private List<String> consumeTemplate(String terminatingLine) {
		List<String> lines = new ArrayList<String>();
		String line;
		try {
			while ((line = br.readLine()) != null) {
				if (line.contains(terminatingLine))
					break;
				lines.add(line);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return lines;
	}
}
